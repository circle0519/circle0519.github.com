---
layout: post
title: '指针点滴-1'
date: '2012-03-22 00:57'
comments: true
categories: ['C/C++']
---

在C和C++语言中，最麻烦当数指针，但是正是有指针才使的C语言如此成功，真是成也萧何败萧何！

1. 首先看声明：
```c
int * p , *q ;  ## 声明了两个int型指针p 和q ;
int* p ,   q ;   ## 声明了一个int型指针p和一个int型变量q;
```
2. 再来看下面的定义的区别：
```c
typedef   int   *pint ;
#define  pint  *int
```
采用第一种定义
```c
pint   a  ,  b  ;
````
这个时候，a 和b都是指向int型的指针变量；

采用第二种定义，同样定义 pint   a  ,  b ;
由宏定义的原理，将原来的字符串只是简单替换掉，等价于： 
```c
int * a  ,  b;
````

这个时候，a为指向int型的指针，b为 int 型变量。

3.返回指向局部变量的指针或者地址
<div class="csharpcode">
<pre><span class="lnum">   1:  </span><span class="kwrd">int</span> *  fun( <span class="kwrd">void</span> )</pre>
<pre><span class="lnum">   2:  </span>{</pre>
<pre><span class="lnum">   3:  </span>        <span class="kwrd">int</span> a = 0 ;</pre>
<pre><span class="lnum">   4:  </span>        <span class="kwrd">return</span> &amp;a ;</pre>
<pre><span class="lnum">   5:  </span>}</pre>
<pre><span class="lnum">   6:  </span></pre>
<pre>很显然，a 为函数的局部变量，在函数执行完之后，其地址空间(栈帧)会被收回，返回的地址空间就是指向不</pre>
<pre>知道存储什么内容的野指针，当然像这种情况编译器会给出警告。但是下面的就不会：</pre>
<div class="csharpcode">
<pre><span class="lnum">   1:  </span><span class="kwrd">int</span>* fun( <span class="kwrd">void</span> )</pre>
<pre><span class="lnum">   2:  </span>{</pre>
<pre><span class="lnum">   3:  </span>       <span class="kwrd">int</span> a = 0 ;</pre>
<pre><span class="lnum">   4:  </span>       <span class="kwrd">int</span> * p = &amp;a ;</pre>
<pre><span class="lnum">   5:  </span>       <span class="kwrd">return</span> p ;</pre>
<pre><span class="lnum">   6:  </span>}</pre>
</div>
<!-- .csharpcode, .csharpcode pre { 	font-size: small; 	color: black; 	font-family: consolas, "Courier New", courier, monospace; 	background-color: #ffffff; 	/*white-space: pre;*/ } .csharpcode pre { margin: 0em; } .csharpcode .rem { color: #008000; } .csharpcode .kwrd { color: #0000ff; } .csharpcode .str { color: #006080; } .csharpcode .op { color: #0000c0; } .csharpcode .preproc { color: #cc6633; } .csharpcode .asp { background-color: #ffff00; } .csharpcode .html { color: #800000; } .csharpcode .attr { color: #ff0000; } .csharpcode .alt  { 	background-color: #f4f4f4; 	width: 100%; 	margin: 0em; } .csharpcode .lnum { color: #606060; } --></div>
<div class="csharpcode">编译器不能把所有情况都检查出来，这个时候就要多加小心野指针的出现。</div>
<div class="csharpcode"></div>
<div class="csharpcode">4.指针与数组</div>
<div class="csharpcode">
<pre><span class="lnum">   1:  </span><span class="kwrd">int</span> a[10];</pre>
<pre><span class="lnum">   2:  </span><span class="kwrd">int</span>* point = &amp;a[0];</pre>
<pre><span class="lnum">   3:  </span>point ++;</pre>
</div>
<!-- .csharpcode, .csharpcode pre { 	font-size: small; 	color: black; 	font-family: consolas, "Courier New", courier, monospace; 	background-color: #ffffff; 	/*white-space: pre;*/ } .csharpcode pre { margin: 0em; } .csharpcode .rem { color: #008000; } .csharpcode .kwrd { color: #0000ff; } .csharpcode .str { color: #006080; } .csharpcode .op { color: #0000c0; } .csharpcode .preproc { color: #cc6633; } .csharpcode .asp { background-color: #ffff00; } .csharpcode .html { color: #800000; } .csharpcode .attr { color: #ff0000; } .csharpcode .alt  { 	background-color: #f4f4f4; 	width: 100%; 	margin: 0em; } .csharpcode .lnum { color: #606060; } --> <!-- .csharpcode, .csharpcode pre { 	font-size: small; 	color: black; 	font-family: consolas, "Courier New", courier, monospace; 	background-color: #ffffff; 	/*white-space: pre;*/ } .csharpcode pre { margin: 0em; } .csharpcode .rem { color: #008000; } .csharpcode .kwrd { color: #0000ff; } .csharpcode .str { color: #006080; } .csharpcode .op { color: #0000c0; } .csharpcode .preproc { color: #cc6633; } .csharpcode .asp { background-color: #ffff00; } .csharpcode .html { color: #800000; } .csharpcode .attr { color: #ff0000; } .csharpcode .alt  { 	background-color: #f4f4f4; 	width: 100%; 	margin: 0em; } .csharpcode .lnum { color: #606060; } -->从第２行，int型指针指向数字a[10]的第一个元素，第3行是指针向后移动一个元素，指向数组中的下一个元素，即a[1]，移动了4个字节。

在数组下标取值时a[i],会自动转化为指向数组头的指针再加上偏移量就是 *( a + i ),因此在取数组值的时候，*(a+i)=*(i+a)即a[i]=i[a];
