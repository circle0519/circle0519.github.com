---
layout: post
title: 设计模式-建造者模式
description: 建造者模式主要将产品构建的整体算法同产品部件的具体构造分离出来，使得产品构建同具体部件之间的构造解耦出来，使系统具有松耦合、更好的复用性及良好的扩展性。
date: '2013-05-04 12:08:33'
categories: ['设计模式']
tags: [设计模式,  建造者模式,  生成器模式,  Java]
---

####定义####
将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。

####例子####
我们拿泡茶和冲咖啡作为简单的例子来简单解释，其中具体过程不必过分深究。
<!--more-->
泡茶:

* 烧热水
* 准备茶叶
* 泡茶

泡咖啡:

* 准备热水
* 准备咖啡
* 冲咖啡

从上面可以知道，它们的制作过程大概都是将水烧开、准备冲剂(茶或咖啡)再就冲制饮料，大概就这3个过程来。我们按照一般普通的思路来完成泡茶和冲咖啡的过程。

<pre><code>泡茶:
public class Tea{
        
    	public void hotWater(){
    	      System.out.println("water hot");
    	}
    	
    	public void prepareTea(){
    	      System.out.println("prepare tea");
    	}
    	
    	public void makeTea(){
    	     System.out.println("make tea sucessful");
    	}
    }
</code></pre>
<pre><code>冲咖啡:
public class Coffea{
        
    	public void hotWater(){
			System.out.println("water hot");
    	}
    	
    	public void prepareCoffea(){
            System.out.println("prepare Coffea");	
		}
    	
    	public void makeCoffea(){
			System.out.println("make coffea successful";
    	}
    }
</code></pre>
<pre>
	<code>客户端调用:
	public class Test{
        public static void main(String[] args){
            Tea tea = new Tea();
			tea.hotwater();
			tea.prepareTea();
			tea.makeTea();
			
            Coffea coffea = new Coffea();
            coffea.hotwater();
			coffea.prepareCoffea();
            coffea.makeCoffea();
		}
	}
	</code>
</pre>
从上清晰的看到，在制作茶和冲咖啡的两个过程有比较大的相似性，即它们在总体的步骤上相似，虽然它们所产生的对象是不同的。而且客户端的调用需要跟类的具体实现相匹配，增大了系统中的耦合性。若系统中再增加一种对象的产生，比如说冲汤，也需要烧开热水、准备汤料，然后冲烫等过程。系统中客户端类就需要修改。而系统的设计尽量做到"对扩展开放，对修改封闭",可见这种设计方法并不合理。
使用建造者模式来解决上面的问题，我们将共同的部分抽象出来，然后让具体的对象来分别实现共同的接口，而客户端只需要针对接口按需要传入不同的建造者就可以生产出不同的对象。

我们改写上面的代码，使其更加合理。

<pre>
    <code>建造者接口
    public interface Builder{
		public void hotwater;
		public void prepare；
		public void make;
	}
	茶建造者:
	public class TeaBuilder implements Builder{
		public void hotwater(){
			System.out.println("hot water");
		}
		public void prepare(){
			System.out.println("prepare tea");
		}
		public void make(){
			System.out.println("make tea successful");
		}
	}
    咖啡建造者:
	public class CoffeaBuilder implements Builder{
		public void hotwater(){
			System.out.println("hot water");
		}
		public void prepare(){
			System.out.println("prepare tea");
		}
		public void make(){
			System.out.println("make coffea successful");
		}
	}
    public class Director{
			Builder builder;
			public Director(Builder builder){
				this.builder = builder;
			}

			public void construct(){
			}
	}
	</code>
</pre>
上面是对建造者模式简单例子介绍。

如果系统中需要新添加对象类型，只需要在系统中添加新类的建造者(实现Builder接口)，客户端可以直接调用,与系统具体实现无关，很好的满足了开闭原则。
建造者模式主要用来构建复杂的产品的过程，将不变的过程集中在建造者接口中，将细节的构造、变化的部分放到接口的实现中来完成，以此相同的接口，相同的总体构建过程，不同的具体的实现来达到产生不同产品的目的。将部件的构造同产品的装配分离开来，这就是建造者模式的核心。

	
