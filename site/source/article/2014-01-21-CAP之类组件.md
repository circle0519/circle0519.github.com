---
layout: post
title: CAP文件之类组件分析
description: 学习记录CAP文件结构定义类型
date: '2014-01-21 12:00:00'
category: JavaCard
tags: [Java, Java Card, 信息安全, CAP]
---

###类组件的定义###
类组件(Class Component)描述了在该包下每个类和接口的定义。但是它不包含每个类和接口的访问信息和内容细节。

取而代之的是它包含了有限的需要跟执行操作箱管的特定类和接口，并且没有执行验证。

关于定义在这包里的类和接口的完整细节包含在描述组件之中。
<!--more-->
对每个接口来说，包含在类组件中的的信息足够来唯一识别和计算这个接口是否合法。

对每个类来说，包含在类组件中的信息足够决定与某个实例相关的一些操作。这些操作包括创建实例，测试实例的计算是否合法，分派虚拟方法调用和分派接口方法调用。

当然累组件中也包含足够的信息来定位实例的类型引用域，包括数组。

在类组件中描述的类以超类，超接口或者实现的接口的形式来引用在类组件中的其他条目。当超类，超接口或者实现的接口定义在导入的包中时，导入组件便会用在引用的表现表现。

描述在类组件的中的类同样包含定义在当前CAP文件中方法组件中虚拟方法的引用。定义在导入包对虚拟方法的引用没有显示的被描述出来，相反这些类被定位通过在类层级中的超类，这些超类被定义在同虚拟方法的一样的导入包中。

常量池组件，导出组件，描述组件和调试组件引用的类和接口被定义在类组件中。没有其他CAP文件中的组件引用类组件。
类组件的描述结构：
<pre class="prettyprint">
class_component{
	u1 tag
	u2 size
	u2 signature_pool_length
	type_descriptor signature_pool[]
	interface_info interfaces[]
}
</pre>
类型解释：

**tag**
tag项的值为COMPONENT_Class值，规定为6;


**size**
size项定义了类组件结构的字节大小，除了tag和size自身项之外。另外size的值必须大于0；

**signature_pool_length**
signature_pool_length描述了在signature_pool项中所占的字节大小。如果这个包中没定义任何远程接口和远程对象，它的值必须为0;

**signature_pool[]**
signature_pool项描述了一列变长的类型描述符结构。这些描述符代表了远程方法的签名。

**interface[]**
interface项代表了一列interface_info结构数组。在包里定义的每个接口在这个数组里都被描述。这些项的顺序按照超接口比其任何子接口序号低的层次排序。
**classes[]**
classes项代表一列变长的class_info结构表，在这个包里定义的每个类都被描述在这个数组里。里面条目的顺序基于超类比其任何子类的更低的序号的层次关系。

###type_descriptor###
*type_descriptor*结构描述了某个域的类型或者方法的签名值。
<pre>
type_descriptor{
	u1 nibble_count;
	u1 type[(nibble_count+1)/2];
}
</pre>
上述结构包括以下两元素。
*nibble_count*
nibble_count的值描述了需要在类型编码在类型数组中的数量。
*type[]*
type数组包含被编码的类型描述符，由一些单独的半字节组成。如果nibble_count是奇数，在类型数组中的最后半个字节必须为0x0.
类型描述符对应的半字节值定义如下:



###interface_info和class_info###
interface_info和class_info结构代表分别接口和类。他们两个有结构中高bit位值不同来区分。结构分别定义如下：
<code class="language-C">
interface_info{
	u1 bitfield{
		bit[4] flags
		bit[4] interface_count
	}
	class_ref superinterfaces[interface_count]
	interface_name_info interface_name
}
</code>

```c
class_info{
	u1 bitfield{
		bit[4] flags
		bit[4] interface_count
	}
	class_ref super_class_ref
	u1 declared_instance_size
	u1 first_reference_token
	u1 reference_count
	u1 public_method_table_base
	u1 public_method_table_count
	u1 package_method_table_base
	u1 package_method_table_count
	u2 public_virtual_method_table[public_method_table_count]
	u2 package_virtual_method_table[package_method_table_count]
	implemented_interface_info interfaces[interface_count]
	remote_interface_info remote_interfaces
}
```
####interface_info与class_info公共项####
**flag**  
flag项是修改器堆栈的掩码，用来描述这个类或者接口。合法的值如下表：

**ACC_INTERFACE**标记标示着这个interface_info或者class_info结构代表着一个接口或者类。
ACC_INTERFACE=1，代表interface_info结构
ACC_INTERFACE=0, 代表class_info结构

*ACC_SHAREABLE*在interface_info结构中标示这个接口是否共享。当且仅当这个接口是javacard.framework.Shareable接口或者扩展这个接口直接或者间接时，这个值为1.

*ACC_REMOTE*标示了这个接口或者类是远程的。当且仅当这个类或者接口满足定义在2.2.6.1
“Remote Classes and Remote Interfaces“要求时，其值为1.

其他标示值被保留。他们的值都是0.

*interface_count*  
在interface_info结构中的interface_count项标示着在superinterfaces[]表格中的项数。这个值代表了这个接口直接或者间接地超接口数。间接地超接口集是直接超接口的超接口集。合法的值在0和14之间，并且包括0和14.
在class_info结构中的interface_count项标示着在接口表格中的书里面。它的值代表着被这个类实现的接口数量，包括这些接口的超类和这个类超类所实现的潜在的接口。合法的值在0到15之间，两边都可以取。


#####interface_info项#####
在interface_info结构中superinterfaces[]项是一系列class_ref结构的数组，代表着这个接口的超接口。class_ref结构被定义CONSTANT_Classref_info结构的一部分。当这个接口没有超接口时，这个结构为空。直接或者间接地超接口都会在这个数组中描述。类对象不包括在内。

*interface_name[]*
interface_name[]项代表需要的接口名信息，如果这个接口是远程的。interface_name[]项是有interface_name_info结构定义的。如果ACC_REMOTE标记为0，结构定义如下
```c
interface_name_info{
	
}
```
如果ACC_REMOTE=1，结构定义如下:
```c
interface_name_info{
	u1 interface_name_length
	u1 interface_name[interface_name_length]
}
```
结构体中定义的细节如下：
interface_name_length标示在interface_name[]中的字节数。
interface_name[]项是变长的这个接口的名称，经UTF-8编码。

#####class_info项#####
super_class_ref
class_info结构中的super_class_ref是个class_ref结构，带表着这个类的超类。class_ref结构定义为CONSTANT_Classref_info结构的一部分。
当只有这个类没有超类时
